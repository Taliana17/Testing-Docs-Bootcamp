import { Entity, PrimaryGeneratedColumn, Column, OneToMany, BeforeInsert, BeforeUpdate } from 'typeorm';
import { Producto } from '../producto/producto.entity';
import * as crypto from 'crypto';

/**
 * Entity representing a supplier in the database.
 * Contains contact information and encrypts the email automatically before saving.
 */
@Entity()
export class Proveedor {
  /**
   * Unique identifier for the supplier, auto-generated by the database.
   */
  @PrimaryGeneratedColumn()
  id_proveedor!: number;

  /**
   * Name of the supplier. 
   */
  @Column()
  nombre: string;

  /**
   * Phone number of the supplier.
   */
  @Column()
  telefono: string;

  /**
   * Encrypted email address of the supplier.
   * Automatically encrypted before insertion or update using AES - 256 -CBC.
   */
  @Column()
  correo: string;

  /**
   * One-to- Many relationship with the Producto (product) entity.
   * A supplier can provide multiple products.
   */
  @OneToMany(() => Producto, (producto) => producto.proveedor)
  productos: Producto[];

  // Claves para encriptación (32 y 16 bytes)
  private readonly ENCRYPTION_KEY = Buffer.from('12345678901234567890123456789012'); // 32 bytes
  private readonly IV = Buffer.from('1234567890123456'); // 16 bytes

  /**
   * Automatically encrypts the email before inserting or updating the entity.
   * only encrypts if the email is not already in hexadecimal format (i.e., not encrypted).
   */
  @BeforeInsert()
  @BeforeUpdate()
  encryptEmail() {
    // Solo encriptar si aún no está en formato hexadecimal
    if (!/^[0-9a-f]+$/.test(this.correo)) {
      const cipher = crypto.createCipheriv('aes-256-cbc', this.ENCRYPTION_KEY, this.IV);
      let encrypted = cipher.update(this.correo, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      this.correo = encrypted;
    }
  }

  /**
      * Returns the decryted email address.
      * Attempts to decrypt the stored hexadecimal value, if it fails, returns the original value.
      * @returns The plaintext email address or the current value decryption fails.
   */
  getDecryptedEmail(): string {
    try {
      const decipher = crypto.createDecipheriv('aes-256-cbc', this.ENCRYPTION_KEY, this.IV);
      let decrypted = decipher.update(this.correo, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      return decrypted;
    } catch {
      // Si ya está desencriptado o falla, se devuelve el valor original
      return this.correo;
    }
  }
}